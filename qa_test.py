import os
import json
import time
import sys

# Try importing the required packages
try:
    from langchain_chroma import Chroma
    from langchain.prompts import ChatPromptTemplate
    from langchain_ollama.llms import OllamaLLM
    from langchain_ollama import OllamaEmbeddings
except ImportError as e:
    missing_package = str(e).split("'")[1]
    print(f"Error: Missing required package: {missing_package}")
    print("\nPlease install all required packages with:")
    print("pip install langchain langchain_community langchain_chroma langchain_ollama chromadb")
    sys.exit(1)

CHROMA_PATH = "chroma"  # Same path as used in load_comments.py


def get_embedding_function():
    """Get the embedding function for the vector database."""
    try:
        return OllamaEmbeddings(model="mxbai-embed-large")
    except Exception as e:
        print(f"Error setting up Ollama embeddings: {str(e)}")
        print("Make sure Ollama is installed and running on your system.")
        print("Visit https://ollama.ai/ for installation instructions.")
        sys.exit(1)


def get_video_metadata_from_db():
    """Retrieve video metadata from the database directory."""
    metadata_file = os.path.join(CHROMA_PATH, "video_metadata.json")

    if os.path.exists(metadata_file):
        try:
            with open(metadata_file, 'r', encoding='utf-8') as f:
                metadata = json.load(f)
                return metadata.get('title', "Unknown Title"), metadata.get('description', "No description available")
        except Exception as e:
            print(f"Error reading video metadata: {str(e)}")

    return "Unknown Title", "No description available"


def answer_question(question, k=70):
    """
    Answer a question based on the YouTube comments with optimized analysis.

    Args:
        question: The user's question about the video comments
        k: Number of relevant comments to retrieve for context

    Returns:
        Answer generated by the LLM
    """
    # Check if database exists
    if not os.path.exists(CHROMA_PATH):
        print("Error: No comment database found! Please run load_comments.py first.")
        return None

    # Start timing
    start_time = time.time()

    # Load the Chroma vector store
    print("Connecting to vector database...")
    db = Chroma(persist_directory=CHROMA_PATH,
                embedding_function=get_embedding_function())

    # Get video metadata for context (only title needed)
    video_title, _ = get_video_metadata_from_db()
    print(f"Loaded metadata for: {video_title}")

    # Define focused QA prompt template
    PROMPT_TEMPLATE = """
    You are a YouTube comment analyst answering questions about video comments.

    VIDEO: {video_title}

    QUESTION: {question}

    RELEVANT COMMENTS:
    {context}

    Answer the question ONLY using information in these comments. Your response should:

    1. Start with a direct answer addressing the question
    2. Group similar opinions together
    3. Include specific quotes from commenters as evidence
    4. Stay STRICTLY focused on the question

    DO NOT include irrelevant information or invent details not in the comments.
    """

    print(f"Retrieving {k} relevant comments for: {question}")

    # Retrieve relevant documents directly
    results = db.similarity_search_with_score(question, k=k)

    retrieval_time = time.time() - start_time
    print(f"Retrieved {len(results)} comments in {retrieval_time:.2f} seconds")

    # Sort comments by relevance score
    sorted_results = sorted(results, key=lambda x: x[1])

    # Build context string - using only top comments to reduce context size
    context_parts = []
    for i, (doc, score) in enumerate(sorted_results[:min(30, len(sorted_results))]):
        # Simpler formatting with just the essential content
        context_parts.append(f"[{i + 1}] {doc.page_content}")

    context_text = "\n\n".join(context_parts)

    # Format prompt with context - keeping it minimal
    prompt_template = ChatPromptTemplate.from_template(PROMPT_TEMPLATE)
    prompt = prompt_template.format(
        question=question,
        context=context_text,
        video_title=video_title
    )

    # Generate answer
    print("Generating answer...")
    model = OllamaLLM(model="llama3.2")

    generation_start = time.time()
    response_text = model.invoke(prompt)
    generation_time = time.time() - generation_start

    print(f"Answer generated in {generation_time:.2f} seconds")

    # Save the output to a file with simplified naming
    filename = f"answer_{hash(question) % 10000}.txt"
    with open(filename, "w", encoding="utf-8") as f:
        f.write(response_text)
    print(f"Answer saved to {filename}")

    total_time = time.time() - start_time
    print(f"Total processing time: {total_time:.2f} seconds")

    return response_text


def main():
    print("=" * 80)
    print("YouTube Comment Q&A Tool (Optimized)")
    print("=" * 80)

    # Check if the database exists
    if not os.path.exists(CHROMA_PATH):
        print("Error: No comment database found!")
        print("Please run load_comments.py first to extract and embed comments.")
        return

    # Get video title from metadata
    video_title, _ = get_video_metadata_from_db()
    print(f"Loaded comments for video: {video_title}")

    # Interactive Q&A loop
    while True:
        print("\nOptions:")
        print("1. Ask a question about the comments")
        print("2. Exit")

        choice = input("\nChoice (1-2): ")

        if choice == "1":
            question = input("\nYour question: ")
            if question.strip():
                print("\nProcessing question...")
                answer = answer_question(question)

                if answer:
                    print("\n" + "=" * 80)
                    print("ANSWER:")
                    print(answer)
                    print("=" * 80)
            else:
                print("Question cannot be empty.")

        elif choice == "2":
            print("\nThank you for using the YouTube Comment Q&A Tool!")
            break

        else:
            print("\nInvalid choice. Please try again.")


if __name__ == "__main__":
    main()